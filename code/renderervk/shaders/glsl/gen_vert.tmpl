#version 450

#define M_PI 3.1415926535897932384626433832795

#if defined(USE_LIGHTMAP) || defined(USE_LIGHT_VECTOR) || defined(USE_LIGHT_VERTEX)
	#define USE_LIGHT
#endif

#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
	#define PER_PIXEL_LIGHTING 
#endif

#if defined(USE_VBO_MDV)
	#define USE_VBO_MODEL

#endif
#ifdef USE_TX2
#define USE_TX1
#endif

#ifdef USE_CL2
#define USE_CL1
#endif

// 64 bytes
layout(push_constant) uniform Transform {
	mat4 mvp;
};

#if defined(USE_FOG) || defined(USE_ENV)
layout(set = 0, binding = 0) uniform UBO {
	// light/env parameters:
	vec4 eyePos;				// vertex
#ifdef USE_ENT_COLOR
	vec4 entColor0;				// fragment: ent.color[0]
	vec4 entColor1;				// fragment: ent.color[1]
	vec4 entColor2;				// fragment: ent.color[2]
#else
	vec4 lightPos;				// vertex: light origin
	vec4 lightColor;			// fragment: rgb + 1/(r*r)
	vec4 lightVector;			// fragment: linear dynamic light
#endif
#ifdef USE_FOG
	// fog parameters:
	vec4 fogDistanceVector;		// vertex
	vec4 fogDepthVector;		// vertex
	vec4 fogEyeT;				// vertex
	vec4 fogColor;				// fragment
#endif
};
#endif

#if defined(PER_PIXEL_LIGHTING) || defined(USE_LIGHT_VECTOR) || defined(USE_VBO_MODEL)
	struct tcMod_t {
		vec4	matrix;
		vec4	offTurb;
	};

	struct tcGen_t {
		vec3	vector0;
		vec3	vector1;
		int		type;
	};

	struct vkBundle_t {
		vec4	baseColor;
		vec4	vertColor;
		tcMod_t	tcMod;
		tcGen_t	tcGen;
		int		rgbGen;
		int		alphaGen;
		int		numTexMods;
	};

	struct vkDeform_t {
		float	base;
		float	amplitude;
		float	phase;
		float	frequency;

		vec3	vector;
		float	time;

		int		type;
		int		func;
	};

	layout(set = 0, binding = 1) uniform Camera {
		vec4 u_ViewOrigin;
	};

	layout(set = 0, binding = 3) uniform Global {
		vkBundle_t			u_bundle[3];
		vkDeform_t			u_deform;
		float				u_portalRange;
		vec4				u_SpecularScale;	
		vec4				u_NormalScale;	
	};	

	layout(set = 0, binding = 2) uniform Entity {
		vec4 u_ambientLight;
		vec4 u_directedLight;
		vec4 u_LocalLightOrigin;
		vec4 u_localViewOrigin;
		mat4 u_ModelMatrix;
	};
#endif

#if defined(PER_PIXEL_LIGHTING)
	layout(location = 9) out vec4 var_Normal;
	layout(location = 10) out vec4 var_LightDir;
	layout(location = 11) out vec4 var_ViewDir;
	layout(location = 12) out vec4 var_Tangent;
#endif

layout(location = 0) in vec3 in_position;

#ifndef USE_ENV
layout(location = 2) in vec2 in_tex_coord0;
#endif

#ifdef USE_TX1
layout(location = 3) in vec2 in_tex_coord1;
#endif
#ifdef USE_TX2
layout(location = 4) in vec2 in_tex_coord2;
#endif

#if defined(PER_PIXEL_LIGHTING) || defined(USE_ENV) || defined(USE_VBO_MDV)
	layout(location = 5) in vec3 in_normal;
#elif defined(USE_LIGHT_VECTOR) && defined(USE_FAST_LIGHT)
	layout(location = 5) in vec3 in_normal;
#endif

#if defined (USE_CLX_IDENT) || defined (USE_FIXED_COLOR)
	// use either 1.0 or fixed (rgb+a) color from spec.constants
#else
	#if !defined(USE_VBO_MODEL)
		layout(location = 1) in vec4 in_color0;
	#endif

	#if defined(USE_CL1) && !defined(USE_VBO_MODEL)
		layout(location = 6) in vec4 in_color1;
	#endif

	#if defined(USE_CL2) && !defined(USE_VBO_MODEL)
		layout(location = 7) in vec4 in_color2;
	#endif

	layout(location = 0) out vec4 frag_color0;

	#ifdef USE_CL1
		layout(location = 5) out vec4 frag_color1;
	#endif

	#ifdef USE_CL2
		layout(location = 6) out vec4 frag_color2;
	#endif
#endif

layout(location = 1) out vec2 frag_tex_coord0;
#ifdef USE_TX1
	layout(location = 2) out vec2 frag_tex_coord1;
#endif
	#ifdef USE_TX2
	layout(location = 3) out vec2 frag_tex_coord2;
#endif

#ifdef USE_FOG
	layout(location = 4) out vec2 fog_tex_coord;
#endif

#if defined(PER_PIXEL_LIGHTING)
	layout(location = 8) in vec4 in_tangent;

	#if !defined(USE_LIGHT_VECTOR)
		layout(location = 9) in vec4 in_lightdir;
	#endif
#endif

out gl_PerVertex {
	vec4 gl_Position;
};

#if defined(USE_VBO_MODEL)
vec4 CalcColor( int index, in vec3 position, in vec3 normal ) {
	vec4 color = ( u_bundle[index].vertColor * vec4( 0.0 ) ) + u_bundle[index].baseColor;		// skip vertColor?

	//switch ( u_bundle[index].rgbGen ) {
	//}

	switch ( u_bundle[index].alphaGen ) {
		case 6: // AGEN_LIGHTING_SPECULAR
		{
			vec3 viewer = normalize( u_localViewOrigin.xyz - position );
			vec3 lightDirection = ( transpose(u_ModelMatrix) * vec4( u_LocalLightOrigin.xyz, 0.0 ) ).xyz;
			vec3 reflected = -reflect( lightDirection, normal );
			color.a = clamp( dot( reflected, normalize( viewer ) ), 0.0, 1.0 );
			color.a *= color.a;
			color.a *= color.a;
			break;
		}
		case 8: // AGEN_PORTAL
		{
			vec3 viewer = normalize( u_localViewOrigin.xyz - position );
			color.a = clamp( length( viewer ) / u_portalRange, 0.0, 1.0 );
			break;
		}
	}

	return color;
}

float GetNoiseValue( float x, float y, float z, float t )
{
	// Variation on the 'one-liner random function'.
	// Not sure if this is still 'correctly' random
	return fract( sin( dot(
		vec4( x, y, z, t ),
		vec4( 12.9898, 78.233, 12.9898, 78.233 )
	)) * 43758.5453 );
}

float CalculateDeformScale( in int func, in float time, in float phase, in float frequency )
{
	float value = phase + time * frequency;

	switch ( func ) {
		case 1: // GF_SIN
			return sin(value * 2.0 * M_PI);
		case 2: // GF_SQUARE
			return sign(0.5 - fract(value));
		case 3: // GF_TRIANGLE
			return abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;
		case 4: // GF_SAWTOOTH
			return fract(value);
		case 5:	// GF_INVERSE_SAWTOOTH
			return 1.0 - fract(value);
		default:// GF_NONE
			return 0.0;
	}
}

vec3 DeformPosition( const vec3 pos, const vec3 normal, const vec2 st )
{
	switch ( u_deform.type ) {
		default:
		{
			return pos;
		}

		case 3: // DEFORM_BULGE
		{
			float bulgeHeight	= u_deform.amplitude;
			float bulgeWidth	= u_deform.phase;
			float bulgeSpeed	= u_deform.frequency;

			float scale = CalculateDeformScale( 1, u_deform.time, bulgeWidth * st.x, bulgeSpeed );

			return pos + normal * scale * bulgeHeight;
		}

		case 4: // DEFORM_BULGE_UNIFORM
		{
			float bulgeHeight = u_deform.amplitude;

			return pos + normal * bulgeHeight;
		}

		case 1: // DEFORM_WAVE
		{
			float base		= u_deform.base;
			float amplitude = u_deform.amplitude;
			float phase		= u_deform.phase;
			float frequency = u_deform.frequency;
			float spread	= u_deform.vector.x;

			float offset = dot( pos.xyz, vec3( spread ) );
			float scale = CalculateDeformScale( u_deform.func, u_deform.time, phase + offset, frequency );

			return pos + normal * (base + scale * amplitude);
		}

		case 5: // DEFORM_MOVE
		{
			float base		= u_deform.base;
			float amplitude = u_deform.amplitude;
			float phase		= u_deform.phase;
			float frequency = u_deform.frequency;
			vec3 direction	= u_deform.vector;

			float scale = CalculateDeformScale( u_deform.func, u_deform.time, phase, frequency );

			return pos + direction * (base + scale * amplitude);
		}

		case 6: // DEFORM_PROJECTION_SHADOW
		{
			vec3 ground = vec3(
				u_deform.base,
				u_deform.amplitude,
				u_deform.phase
			);

			float groundDist	= u_deform.frequency;
			vec3 lightDir		= u_deform.vector;

			float d = 1.0 / dot( lightDir, ground );
			vec3 lightPos = lightDir * d;
			return pos - lightPos * (dot( pos, ground ) + groundDist);
		}
	}
}

vec3 DeformNormal( const in vec3 position, const in vec3 normal )
{
	if ( u_deform.type != 2 ) // DEFORM_NORMALS
		return normal;

	float amplitude = u_deform.amplitude;
	float frequency = u_deform.frequency;

	vec3 outNormal = normal;
	const float scale = 0.98;

	outNormal.x += amplitude * GetNoiseValue(
		position.x * scale,
		position.y * scale,
		position.z * scale,
		u_deform.time * frequency );

	outNormal.y += amplitude * GetNoiseValue(
		100.0 * position.x * scale,
		position.y * scale,
		position.z * scale,
		u_deform.time * frequency );

	outNormal.z += amplitude * GetNoiseValue(
		200.0 * position.x * scale,
		position.y * scale,
		position.z * scale,
		u_deform.time * frequency );

	return outNormal;
}
#endif

vec2 GenTexCoords(const in vec2 tc, int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)
{
	vec2 tex = tc;

	if ( TCGen == 7 ) // TCGEN_VECTOR
		tex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));

	return tex;
}

vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)
{
	float amplitude = offTurb.z;
	float phase = offTurb.w * 2.0 * M_PI;
	vec2 st2;
	st2.x = st.x * texMatrix.x + (st.y * texMatrix.z + offTurb.x);
	st2.y = st.x * texMatrix.y + (st.y * texMatrix.w + offTurb.y);

	vec2 offsetPos = vec2(position.x + position.z, position.y);
	
	vec2 texOffset = sin(offsetPos * (2.0 * M_PI / 1024.0) + vec2(phase));
	
	return st2 + texOffset * amplitude;	
}

void main() {
#if defined(USE_VBO_MDV)
	vec3 position = in_position;
	vec3 normal = normalize(in_normal);

	#ifdef PER_PIXEL_LIGHTING
		vec3 tangent = normalize(in_tangent.xyz);
	#endif

	if ( u_deform.type != 0 ){ // !DEFORM_NONE
		position	= DeformPosition( position, normal, frag_tex_coord0 );
		normal		= DeformNormal( position, normal );
	}
#elif defined(USE_BONE_ANIMATION)
	// ..
#else
	vec3 position = in_position;

	#if defined(USE_ENV) || (defined(USE_LIGHT) && (!defined(USE_FAST_LIGHT) || defined(USE_LIGHT_VECTOR)))
		vec3 normal = in_normal;
	#endif

	#ifdef PER_PIXEL_LIGHTING
		vec3 tangent = in_tangent.xyz;
	#endif
#endif
	
#if defined (USE_CLX_IDENT) || defined (USE_FIXED_COLOR)
	// use either 1.0 or fixed (rgb+a) color from spec.constants
#else
	#if defined(USE_VBO_MODEL)
		frag_color0 = CalcColor( 0, position, normal );
	#else
		frag_color0 = in_color0;
	#endif

	#ifdef USE_CL1
		#if defined(USE_VBO_MODEL)
			frag_color1 = CalcColor( 1, position, normal );
		#else
			frag_color1 = in_color1;
		#endif
	#endif

	#ifdef USE_CL2
		#if defined(USE_VBO_MODEL)
			frag_color2 = CalcColor( 2, position, normal );
		#else
			frag_color2 = in_color2;
		#endif
	#endif
#endif

	gl_Position = mvp * vec4(position, 1.0);

#ifdef USE_ENV
	vec3 viewer = normalize(eyePos.xyz - position);
	float d = dot(normal, viewer); 
	vec2 reflected = normal.yz * 2 * d - viewer.yz;

	frag_tex_coord0.s = 0.5 + reflected.x * 0.5;
	frag_tex_coord0.t = 0.5 - reflected.y * 0.5;
#else
	frag_tex_coord0 = in_tex_coord0;
#endif

#ifdef USE_TX1
	frag_tex_coord1 = in_tex_coord1;
#endif
#ifdef USE_TX2
	frag_tex_coord2 = in_tex_coord2;
#endif

// tcGen & tcMod
#if defined(USE_VBO_MODEL)
	#ifndef USE_ENV
		frag_tex_coord0 = GenTexCoords( in_tex_coord0.st, u_bundle[0].tcGen.type, position, normal, u_bundle[0].tcGen.vector0, u_bundle[0].tcGen.vector1 );
	#endif

	if ( u_bundle[0].numTexMods > 0 ) {
		frag_tex_coord0 = ModTexCoords( frag_tex_coord0, position, u_bundle[0].tcMod.matrix, u_bundle[0].tcMod.offTurb );
	}
	#ifdef USE_TX1
		if ( u_bundle[1].numTexMods > 0 ) {
			frag_tex_coord1 = ModTexCoords( frag_tex_coord1, position, u_bundle[1].tcMod.matrix, u_bundle[1].tcMod.offTurb );
		}
	#endif

	#ifdef USE_TX2
		if ( u_bundle[2].numTexMods > 0 ) {
			frag_tex_coord2 = ModTexCoords( frag_tex_coord2, position, u_bundle[2].tcMod.matrix, u_bundle[2].tcMod.offTurb );
		}
	#endif
#endif

#ifdef USE_FOG
	float s = dot(position, fogDistanceVector.xyz) + fogDistanceVector.w;
	float t = dot(position, fogDepthVector.xyz) + fogDepthVector.w;

	if ( fogEyeT.y == 1.0 ) {
		if ( t < 0.0 ) {
			t = 1.0 / 32.0;
		} else {
			t = 31.0 / 32.0;
		}
	} else {
		if ( t < 1.0 ) {
			t = 1.0 / 32.0;
		} else {
			t = 1.0 / 32.0 + (30.0 / 32.0 * t) / ( t - fogEyeT.x );
		}
	}

	fog_tex_coord = vec2(s, t);
#endif // USE_FOG

#ifdef USE_LIGHT
	#if !defined(USE_FAST_LIGHT) || defined(USE_LIGHT_VECTOR)
		position		= (u_ModelMatrix * vec4(position, 1.0)).xyz;
		normal			= normalize(mat3(u_ModelMatrix) * normal);
		#if !defined(USE_FAST_LIGHT)
			tangent			= normalize(mat3(u_ModelMatrix) * tangent);
		#endif
	#endif

	#if defined(USE_LIGHT_VECTOR)
		vec3 L	= u_LocalLightOrigin.xyz - (position * u_LocalLightOrigin.w);
	#elif defined(PER_PIXEL_LIGHTING)
		//vec3 L	= in_lightdir.xyz * 2.0 - vec3(1.0);
		vec3 L	= in_lightdir.xyz;
		L		= ( u_ModelMatrix * vec4( L, 0.0 ) ).xyz;
		//L		= normalize( ( L * 0.5 ) + vec3( 0.5 ) );
	#endif
#endif

#if defined (USE_CLX_IDENT) || defined (USE_FIXED_COLOR)
	// use either 1.0 or fixed (rgb+a) color from spec.constants
#else
	#if defined(USE_LIGHT_VECTOR) && defined(USE_FAST_LIGHT)
		float sqrLightDist = dot(L, L);
		float NL = clamp(dot(normal, L) / sqrt(sqrLightDist), 0.0, 1.0);

		frag_color0.rgb *= u_directedLight.rgb * NL + u_ambientLight.rgb;

		#ifdef USE_CL1
			frag_color1.rgb *= u_directedLight.rgb * NL + u_ambientLight.rgb;
		#endif
		#ifdef USE_CL2
			frag_color2.rgb *= u_directedLight.rgb * NL + u_ambientLight.rgb;
		#endif
	#endif
#endif

#ifdef PER_PIXEL_LIGHTING 
	vec3 viewDir = u_ViewOrigin.xyz - position;

	var_LightDir	= vec4(L, 0.0);
	var_Normal		= vec4(normal, 0.0);
	var_ViewDir		= vec4(viewDir, 0.0);
	var_Tangent		= vec4(tangent, in_tangent.w);
#endif
}
