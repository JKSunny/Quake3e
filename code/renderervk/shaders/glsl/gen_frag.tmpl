#version 450

#ifdef USE_TX2
#define USE_TX1
#endif

#ifdef USE_CL2
#define USE_CL1
#endif

#if defined(USE_FOG) || defined(USE_VK_PBR)
layout(set = 1, binding = 0) uniform UBO {
	// VERTEX
	vec4 eyePos;
	vec4 lightPos;
	//  VERTEX-FOG
	vec4 fogDistanceVector;
	vec4 fogDepthVector;
	vec4 fogEyeT;
	// FRAGMENT
	vec4 lightColor;
	vec4 fogColor;
	// linear dynamic light
	vec4 lightVector;
};
#endif

layout(set = 2, binding = 0) uniform sampler2D texture0;
#ifdef USE_TX1
layout(set = 3, binding = 0) uniform sampler2D texture1;
#endif
#ifdef USE_TX2
layout(set = 4, binding = 0) uniform sampler2D texture2;
#endif
#ifdef USE_FOG
layout(set = 5, binding = 0) uniform sampler2D fog_texture;
#endif

#ifdef USE_CL0_IDENT
// use fixed color from spec.constant.8
#else
layout(location = 0) in vec4 frag_color0;
#endif

#ifdef USE_CL1
layout(location = 5) in vec4 frag_color1;
#endif
#ifdef USE_CL2
layout(location = 6) in vec4 frag_color2;
#endif

layout(location = 1) centroid in vec2 frag_tex_coord0;
#ifdef USE_TX1
layout(location = 2) centroid in vec2 frag_tex_coord1;
#endif
#ifdef USE_TX2
layout(location = 3) centroid in vec2 frag_tex_coord2;
#endif
#ifdef USE_FOG
layout(location = 4) in vec2 fog_tex_coord;
#endif

#ifdef USE_DF
layout(depth_less) out float gl_FragDepth;
#else
layout(location = 0) out vec4 out_color;
#endif

#ifdef USE_ATEST
layout (constant_id = 0) const int alpha_test_func = 0;
layout (constant_id = 1) const float alpha_test_value = 0.0;
#ifdef USE_DF
layout (constant_id = 2) const float depth_fragment = 0.85;
#endif
#endif

layout (constant_id = 3) const int alpha_to_coverage = 0;
//layout (constant_id = 4) const int color_mode = 0;
//layout (constant_id = 5) const int abs_light = 0;
#if defined (USE_TX1) || defined(USE_TX2)
layout (constant_id = 6) const int tex_mode = 0; // modulate, add (identity), add(non-identity) etc
#endif
layout (constant_id = 7) const int discard_mode = 0;
#ifdef USE_CL0_IDENT
layout (constant_id = 8) const float identity_color = 1.0;
#endif

#ifdef USE_VK_PBR
#define PI 3.1415926535897932384626433832795

const float min_roughness = 0.04;
const vec4 u_lightDir = vec4( 0.7399, 0.6427, 0.19827, 0.0);	// staticly define light for now
const vec3 u_LightColor = vec3( 1.0 );
const vec3 f0 = vec3(0.004);

struct NTB {
	vec3 normal, tangent, binormal;
};

layout(location = 9) in vec3 in_position;
layout(location = 10) in NTB in_ntb;

layout(set = 6, binding = 0) uniform sampler2D brdflut_texture;
layout(set = 7, binding = 0) uniform sampler2D normal_texture;
layout(set = 8, binding = 0) uniform sampler2D physical_texture;

layout (constant_id = 9) const float metallic_value = 1.0;
layout (constant_id = 10) const float roughness_value = 1.0;

layout (constant_id = 11) const int normal_texture_set = 0;
layout (constant_id = 12) const int physical_texture_set  = 0;

// PBR shader source from SaschaWillems https://github.com/SaschaWillems/Vulkan-glTF-PBR
struct PBRInfo
{
	float NdotL;                  // cos angle between normal and light direction
	float NdotV;                  // cos angle between normal and view direction
	float NdotH;                  // cos angle between normal and half vector
	float LdotH;                  // cos angle between light direction and half vector
	float VdotH;                  // cos angle between view direction and half vector
	float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
	float metalness;              // metallic value at the surface
	vec3 reflectance0;            // full reflectance color (normal incidence angle)
	vec3 reflectance90;           // reflectance color at grazing angle
	float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
	vec3 diffuseColor;            // color contribution from diffuse lighting
	vec3 specularColor;           // color contribution from specular lighting
};

// From http://filmicgames.com/archives/75
vec3 Uncharted2Tonemap(vec3 x)
{
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

vec3 AcesTonemap(vec3 x) {
  const float a = 2.51;
  const float b = 0.03;
  const float c = 2.43;
  const float d = 0.59;
  const float e = 0.14;
  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}

vec4 tonemap(vec4 color)
{
	vec3 outcol = Uncharted2Tonemap(color.rgb * 3.0);
	outcol = outcol * (1.0f / Uncharted2Tonemap(vec3(11.2f)));	
	return vec4(pow(outcol, vec3(1.0f /2.0)), color.a);
}

vec3 calculateNormal()
{
    vec3 tangentNormal = (texture(normal_texture, frag_tex_coord0).xyz * 2.0) - vec3(1.0);
    vec3 N = normalize(in_ntb.normal);
    vec3 T = normalize(in_ntb.tangent);
    vec3 B = normalize(cross(N, T));
    mat3 TBN = mat3(vec3(vec3(T)), vec3(vec3(B)), vec3(vec3(N)));
    return normalize(TBN * tangentNormal);
}

#define MANUAL_SRGB 1
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
	#ifdef MANUAL_SRGB
	#ifdef SRGB_FAST_APPROXIMATION
	vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
	#else //SRGB_FAST_APPROXIMATION
	vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
	vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
	#endif //SRGB_FAST_APPROXIMATION
	return vec4(linOut,srgbIn.w);;
	#else //MANUAL_SRGB
	return srgbIn;
	#endif //MANUAL_SRGB
}

vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
	float lod = pbrInputs.perceptualRoughness;
	//float lod = (pbrInputs.perceptualRoughness * 1.0);

	// retrieve a scale and bias to F0. See [1], Figure 3
	vec3 brdf = (texture(brdflut_texture, vec2(pbrInputs.NdotV, 0.87 - pbrInputs.perceptualRoughness))).rgb;

	// image based lighting	
	//vec3 diffuseLight = SRGBtoLINEAR(tonemap(texture(texture0, n))).rgb;
	//vec3 specularLight = SRGBtoLINEAR(tonemap(textureLod(texture0, reflection, lod))).rgb;

	vec3 diffuse = pbrInputs.diffuseColor;
	vec3 specular = (pbrInputs.specularColor * brdf.x + brdf.y);

	// For presentation, this allows us to disable IBL terms
	//diffuse *= 1.0;
	//specular *= 1.0;

	return diffuse + specular;
}

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 diffuse(PBRInfo pbrInputs)
{
	return pbrInputs.diffuseColor / PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInputs)
{
	return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInputs)
{
	float NdotL = pbrInputs.NdotL;
	float NdotV = pbrInputs.NdotV;
	float r = pbrInputs.alphaRoughness;

	float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
	float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
	return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInputs)
{
	float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
	float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
	return roughnessSq / (PI * f * f);
}
#endif

#ifdef USE_ATEST
float CorrectAlpha(float threshold, float alpha, vec2 tc)
{
	ivec2 ts = textureSize(texture0, 0);
	float dx = max(abs(dFdx(tc.x * float(ts.x))), 0.001);
	float dy = max(abs(dFdy(tc.y * float(ts.y))), 0.001);
	float dxy = max(dx, dy); // apply the smallest boost
	float scale = max(1.0 / dxy, 1.0);
	float ac = threshold + (alpha - threshold) * scale;
	return ac;
}
#endif

void main() {
#ifdef USE_FOG
	vec4 fog = texture(fog_texture, fog_tex_coord);
#endif

#ifdef USE_CL0_IDENT
	vec4 color0 = texture(texture0, frag_tex_coord0) * vec4( identity_color );
#else
	vec4 color0 = texture(texture0, frag_tex_coord0) * frag_color0;
#endif

	vec4 base;

#if defined (USE_TX2)
#ifdef USE_CL2
	// soecial blend modes for non-identity colors
	if ( tex_mode == 1 || tex_mode == 2 )
	{
		// add
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = texture(texture2, frag_tex_coord2) * frag_color2;

		base = vec4( color0.rgb + color1.rgb + color2.rgb, color0.a * color1.a * color2.a );
	}
	else if ( tex_mode == 3 )
	{
		// modulate by alpha
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = texture(texture2, frag_tex_coord2) * frag_color2;

		color0 *= color0.a;
		color1 *= color1.a;
		color2 *= color2.a;
		base = vec4( color0.rgb + color1.rgb + color2.rgb, color0.a * color1.a * color2.a );
	}
	else if ( tex_mode == 4 )
	{
		// modulate by 1.0-alpha
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = texture(texture2, frag_tex_coord2) * frag_color2;

		color0 *= 1.0-color0.a;
		color1 *= 1.0-color1.a;
		color2 *= 1.0-color2.a;
		base = vec4( color0.rgb + color1.rgb + color2.rgb, color0.a * color1.a * color2.a );
	}
	else if ( tex_mode == 5 )
	{
		// mix by src alpha
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = texture(texture2, frag_tex_coord2) * frag_color2;

		//base = mix( color0, color1, color1.a );
		//base = mix( base, color2, color2.a );
		base = mix( mix( color0, color1, color1.a ), color2, color2.a );
	}
	else if ( tex_mode == 6 )
	{
		// mix by 1-src alpha
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = texture(texture2, frag_tex_coord2) * frag_color2;

		//base = mix( color1, color0, color1.a );
		//base = mix( color2, base, color2.a );
		base = mix( color2, mix( color1, color0, color1.a ), color2.a );
	}
	else if ( tex_mode == 7 ) // 0 + 2x GLS_DSTBLEND_SRC_ALPHA | GLS_SRCBLEND_DST_COLOR
	{
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = texture(texture2, frag_tex_coord2) * frag_color2;

		base = (color2 + color2.a) * (color1 + color1.a) * color0;
	}
	else
	{
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		vec4 color2 = texture(texture2, frag_tex_coord2) * frag_color2;
		base = color0 * color1 * color2;
	}
#else
	// triple-texture blending
	if ( tex_mode == 1 )
	{
		// add (identity)
		vec4 color1 = texture(texture1, frag_tex_coord1);
		vec4 color2 = texture(texture2, frag_tex_coord2);
		base = vec4(color0.rgb + color1.rgb + color2.rgb, color0.a * color1.a * color2.a);
	}
	else if ( tex_mode == 2 )
	{
		// add
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color0;
		vec4 color2 = texture(texture2, frag_tex_coord2) * frag_color0;
		base = vec4(color0.rgb + color1.rgb + color2.rgb, color0.a * color1.a * color2.a);
	}
	else 
	{
		// default case, modulate
		vec4 color1 = texture(texture1, frag_tex_coord1);
		vec4 color2 = texture(texture2, frag_tex_coord2);
		base = color0 * color1 * color2;
	}
#endif // !USE_TX2
#elif defined(USE_TX1)
#ifdef USE_CL1
	// soecial blend modes for non-identity colors
	if ( tex_mode == 1 || tex_mode == 2 )
	{
		// add
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		base = vec4( color0.rgb + color1.rgb, color0.a * color1.a );
	}
	else if ( tex_mode == 3 ) // 2x GLS_DSTBLEND_ONE | GLS_SRCBLEND_SRC_ALPHA
	{
		// modulate by alpha
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		color0 *= color0.a;
		color1 *= color1.a;
		base = vec4( color0.rgb + color1.rgb, color0.a * color1.a );
	}
	else if ( tex_mode == 4 ) // 2x GLS_DSTBLEND_ONE | GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA
	{
		// modulate by 1.0-alpha
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		color0 *= 1.0-color0.a;
		color1 *= 1.0-color1.a;
		base = vec4( color0.rgb + color1.rgb, color0.a * color1.a );
	}
	else if ( tex_mode == 5 ) // 0 + GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA | GLS_SRCBLEND_SRC_ALPHA
	{
		// mix by src alpha
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		base = mix( color0, color1, color1.a );
	}
	else if ( tex_mode == 6 ) // 0 + GLS_DSTBLEND_SRC_ALPHA | GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA
	{
		// mix by 1-src alpha
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		base = mix( color1, color0, color1.a );
	}
	else if ( tex_mode == 7 ) // 0 + GLS_DSTBLEND_SRC_ALPHA | GLS_SRCBLEND_DST_COLOR
	{
		// modulate color1 by color0
		// moduleta color0 by color1.alpha
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		base = (color1 + color1.a) * color0;
	}
	else
	{
		// default case, modulate
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color1;
		base = color0 * color1;
	}
#else
	// double-texture blending
	if ( tex_mode == 1 )
	{
		// add (identity)
		vec4 color1 = texture(texture1, frag_tex_coord1);
		base = vec4(color0.rgb + color1.rgb, color0.a * color1.a);
	}
	else if ( tex_mode == 2 )
	{
		// add
		vec4 color1 = texture(texture1, frag_tex_coord1) * frag_color0;
		base = vec4(color0.rgb + color1.rgb, color0.a * color1.a);
	}
	else // default case
	{
		// modulate
		vec4 color1 = texture(texture1, frag_tex_coord1);
		base = color0 * color1;
	}
#endif // !USE_CL1
#endif // !USE_TX1

#ifdef USE_ATEST
	if (alpha_to_coverage != 0) {
		if (alpha_test_func == 1) {
			base.a =  base.a > 0.0 ? 1.0 : 0.0;
		} else if (alpha_test_func == 2) {
			base.a = CorrectAlpha(alpha_test_value, 1.0 - base.a, frag_tex_coord0);
		} else if (alpha_test_func == 3) {
			base.a = CorrectAlpha(alpha_test_value, base.a, frag_tex_coord0);
		}
	} else
	// specialization: alpha-test function
	if (alpha_test_func == 1) {
		if (color0.a == alpha_test_value) discard;
	} else if (alpha_test_func == 2) {
		if (color0.a >= alpha_test_value) discard;
	} else if (alpha_test_func == 3) {
		if (color0.a < alpha_test_value) discard;
	}
#endif

#if !defined(USE_TX1) && !defined(USE_TX2)
	base = color0;
#endif

#ifdef USE_FOG
	base = mix( base, fog * fogColor, fog.a );
#endif

	if ( discard_mode == 1 ) {
		if ( base.a == 0.0 ) {
			discard;
		}
	} else if ( discard_mode == 2 ) {
		if ( dot( base.rgb, base.rgb ) == 0.0 ) {
			discard;
		}
	}

#ifdef USE_DF
	if ( base.a < depth_fragment )
		discard;

	gl_FragDepth = gl_FragCoord.z;
#else
#ifdef USE_VK_PBR
	float perceptualRoughness;
	float metallic;
	vec3 diffuseColor;

	{
		perceptualRoughness = roughness_value;
		metallic = metallic_value;

		if ( physical_texture_set > -1 ) {
			vec2 mrSample = texture(physical_texture, frag_tex_coord0).rg;

			perceptualRoughness = mrSample.r * perceptualRoughness;
			metallic = mrSample.g * metallic;
		} else {
			perceptualRoughness = clamp(perceptualRoughness, min_roughness, 1.0);
			metallic = clamp(metallic, 0.0, 1.0);
		}
	}

	diffuseColor = base.rgb * (vec3(1.0) - f0);
	diffuseColor *= 1.0 - metallic;

	float alphaRoughness = perceptualRoughness * perceptualRoughness;
	vec3 specularColor = mix(f0, base.rgb, metallic);

	// Compute reflectance.
	float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

	// For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
	// For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
	float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
	vec3 specularEnvironmentR0 = specularColor.rgb;
	vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

	vec3 n = ( normal_texture_set > -1 ) ? calculateNormal() : normalize( in_ntb.normal );
	vec3 v = normalize( eyePos.xyz - in_position );	// Vector from surface point to camera
	vec3 l = normalize( u_lightDir.xyz );			// Vector from surface point to light
	vec3 h = normalize( l + v );                    // Half vector between both l and v
	vec3 r = -normalize( reflect( v, n ) );
	r.y *= -1.0f;

	float NdotL = clamp( dot( n, l ), 0.001, 1.0 );
	float NdotV = clamp( abs( dot( n, v ) ), 0.001, 1.0 );
	float NdotH = clamp( dot( n, h ), 0.0, 1.0 );
	float LdotH = clamp( dot( l, h ), 0.0, 1.0 );
	float VdotH = clamp( dot( v, h ), 0.0, 1.0 );

	PBRInfo pbrInputs = PBRInfo(
		NdotL,
		NdotV,
		NdotH,
		LdotH,
		VdotH,
		perceptualRoughness,
		metallic,
		specularEnvironmentR0,
		specularEnvironmentR90,
		alphaRoughness,
		diffuseColor,
		specularColor
	);

	vec3 F = specularReflection( pbrInputs );
	float G = geometricOcclusion( pbrInputs );
	float D = microfacetDistribution( pbrInputs );

	// Calculation of analytical lighting contribution
	vec3 diffuseContrib = ( 1.0 - F ) * diffuse( pbrInputs );
	vec3 specContrib = F * G * D / ( 4.0 * NdotL * NdotV );
	
	// Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
	vec3 color = NdotL * u_LightColor * ( diffuseContrib + specContrib );

	// Calculate optional lighting contribution from image based lighting source (IBL)
	color += getIBLContribution( pbrInputs, n, r );

	const float u_OcclusionStrength = 1.0f;
	if ( physical_texture_set > -1 ) {
		float ao = texture( physical_texture, frag_tex_coord0 ).b;
		color = mix( color, color * ao, u_OcclusionStrength );
	}

	//const float u_EmissiveFactor = 1.0f;
	//if ( emissive_texture_set > -1 ) {
	//	vec3 emissive = SRGBtoLINEAR( texture( emissiveMap, frag_tex_coord0 ).rgb * u_EmissiveFactor;
	//	color += emissive;
	//}

	// Tonemap
	//color = Uncharted2Tonemap( color * 1.9 );
	//color = color * ( 1.0f / Uncharted2Tonemap( vec3( 6.2f ) ) );
	//color = pow(color, vec3(1.0f / 1.2));

	//color = AcesTonemap( color * 0.9 );
	//color = color * ( 1.0f / AcesTonemap( vec3( 11.2f ) ) );

	out_color = vec4( color, base.a );
#else
	out_color = base;
#endif
#endif
}
